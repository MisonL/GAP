# 缓存优化计划

## 引言

本计划旨在探讨并实现如何利用Google Gemini API提供的上下文缓存功能来优化程序的token使用，同时兼容程序现有的多API Key轮换机制。通过引入缓存，我们期望在处理重复性或大型上下文内容时，能够显著降低API调用的成本和延迟。

## 用户方案概述

为了将Gemini API的原生缓存功能集成到多Key轮换机制中，用户提出了以下核心方案：

1. **用户开关：** 提供一个用户级别的配置开关，允许用户选择是否启用“原生缓存功能”。
2. **互斥关系：** 如果用户选择开启“原生缓存功能”，则强制关闭“自动补全上下文功能”。
3. **新的Key选用机制（粘性会话）：** 如果开启“原生缓存功能”，该用户的请求将采用“粘性会话”机制，尽量使用同一个API Key进行请求，但仍需遵守模型限制规则。
4. **默认行为：** 如果关闭“原生缓存功能”，则程序行为与之前一致，用户可以自由选择是否开启“自动补全上下文功能”。

## 最终计划详细步骤 (状态更新 - 基于当前版本)

基于用户提出的方案和对Gemini API缓存特性及项目源码的分析，制定以下详细实现步骤：

1. **[未实现]** **用户配置：** 在配置文件或数据库中增加一个用户级别的配置项（例如 `enable_native_caching`），用于控制是否开启“原生缓存功能”。
2. **[未实现]** **依赖管理：** 更新 `requirements.txt` 文件，添加 `google-genai>=1.0.0` 库。**当前 `requirements.txt` 中缺少此依赖。**
3. **[未实现]** **数据库设计：** 在数据库中创建一个 `cached_contents` 表，用于存储缓存的元数据。
4. **[未实现]** **请求处理流程修改 (`app/api/request_processor.py` 或相关文件):**
    * **当前状态:** 未实现缓存相关逻辑。现有请求处理流程已包含 Key 选择、Token 预检查、动态截断和错误重试的基础。
    * **计划:** 根据用户配置启用缓存逻辑，强制关闭自动补全，计算哈希，查询/创建缓存，处理错误，控制并发，实现失效机制。
5. **[未实现]** **Key选择逻辑修改 (`app/core/key_management.py` 或相关文件):**
    * **当前状态:** 未实现“粘性会话”和 Key 与缓存的关联。现有 Key 选择逻辑已实现基于评分、Token 预检查和轮转。
    * **计划:** 增加对“粘性会话”的支持，维护用户-Key 映射，优先选择关联 Key，处理关联 Key 不可用时的回退，管理 Key 与缓存的关联。
6. **[未实现]** **实现缓存管理模块：**
    * **当前状态:** 未实现。没有 `app/core/cache_manager.py` 或类似模块。
    * **计划:** 创建新模块，使用 `google.genai` 库处理缓存创建、更新、删除，与数据库交互，实现失效逻辑。
7. **[未实现]** **重构 `GeminiClient` 类 (`app/core/gemini.py`):**
    * **当前状态:** 未实现。`GeminiClient` **未使用** `google.genai` SDK，也**不支持** `cached_content_id` 参数。
    * **计划:** 将 `GeminiClient` 实现切换到 `google.genai` SDK，修改方法以支持 `cached_content_id`，适配请求/响应格式。
8. **[未实现]** **更新报告和追踪：**
    * **当前状态:** 未实现缓存使用情况的报告和追踪。现有报告和追踪已包含 Key 使用情况和筛选原因统计的基础。
    * **计划:** 修改 `reporting.py` 和 `tracking.py` 以记录和报告缓存命中、节省的 token 等信息。需与 Key 筛选报告整合。
9. **[未实现]** **编写测试：**
    * **当前状态:** 未实现。没有针对缓存功能的测试。
    * **计划:** 为新模块和修改后的类编写单元测试，编写集成测试和性能测试。
10. **[未实现]** **（可选）增加缓存管理接口和前端支持：**
    * **当前状态:** 未实现。没有相关的 API 端点和前端界面。
    * **计划:** 如果需要，增加 API 端点和前端支持，并在 UI 中明确说明功能互斥关系。

11. **[未实现]** **数据库迁移方案**:
    * **当前状态:** 未实现。
    * **计划:** 为 `cached_contents` 表结构变化提供迁移方案。
12. **[未实现]** **后台清理任务**:
    * **当前状态:** 未实现。现有清理任务不包含缓存清理。
    * **计划:** 增加定期清理过期或无效缓存元数据的任务。

## 缓存适用内容和管理策略

* **适用内容：** 固定的系统指令和用户上传的大型文档/代码片段。
* **触发机制：**
  * 系统指令：当系统指令的token数超过阈值时自动缓存。
  * 用户上传内容：提供用户选择是否缓存的选项。
* **管理策略：**
  * 使用数据库存储缓存元数据和关联的Key。
  * 利用Gemini API的TTL管理缓存失效。
  * 实现基于内容哈希的缓存查找和更新。
  * 实现基于用户和Key的“粘性会话”Key选择策略。
  * 可选择提供手动管理缓存的接口。

## 流程示意图

```mermaid
graph TD
    A[用户请求] --> B{用户开启原生缓存?};
    B -- 否 --> C[按原有机制处理请求];
    B -- 是 --> D[强制关闭自动补全上下文];
    D --> E{内容是否可缓存?};
    E -- 是 --> F{内容是否已缓存且Key匹配?};
    F -- 是 --> G[构建API请求<br>引用缓存ID];
    F -- 否 --> H[选择Key<br>优先关联Key];
    H --> I{Key选择成功?};
    I -- 是 --> J[构建API请求<br>包含完整内容];
    I -- 否 --> K[Key选择失败<br>返回错误];
    J --> L[调用Gemini API];
    G --> L;
    L --> M[接收API响应];
    M --> N{缓存创建成功?};
    N -- 是 --> O[存储缓存元数据];
    N -- 否 --> P[记录缓存创建失败];
    M --> Q[处理响应<br>解析UsageMetadata];
    Q --> R[更新用户与Key关联];
    Q --> S[返回结果给用户];
    C --> S;
    K --> S;
