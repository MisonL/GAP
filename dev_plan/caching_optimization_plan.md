# 缓存优化计划

## 引言

本计划旨在探讨并实现如何利用Google Gemini API提供的上下文缓存功能来优化程序的token使用，同时兼容程序现有的多API Key轮换机制。通过引入缓存，我们期望在处理重复性或大型上下文内容时，能够显著降低API调用的成本和延迟。

## 用户方案概述

为了将Gemini API的原生缓存功能集成到多Key轮换机制中，用户提出了以下核心方案：

1. **用户开关：** 提供一个用户级别的配置开关，允许用户选择是否启用“原生缓存功能”。
2. **互斥关系：** 如果用户选择开启“原生缓存功能”，则强制关闭“自动补全上下文功能”。
3. **新的Key选用机制（粘性会话）：** 如果开启“原生缓存功能”，该用户的请求将采用“粘性会话”机制，尽量使用同一个API Key进行请求，但仍需遵守模型限制规则。
4. **默认行为：** 如果关闭“原生缓存功能”，则程序行为与之前一致，用户可以自由选择是否开启“自动补全上下文功能”。

## 最终计划详细步骤 (状态更新 - 基于当前版本)

基于用户提出的方案和对Gemini API缓存特性及项目源码的分析，制定以下详细实现步骤：

1. **[已实现]** **用户配置：** 在 `app/config.py` 中增加了 `ENABLE_NATIVE_CACHING` 配置项。
2. **[已实现]** **依赖管理：** `requirements.txt` 文件已包含 `google-genai>=1.0.0` 库。
3. **[已实现]** **数据库设计：** 在 `app/core/db_models.py` 的 `CachedContent` 模型中添加了 `user_id` 字段和索引。
4. **[已实现]** **请求处理流程修改 (`app/api/request_processing.py`):**
    * **当前状态:** 已修改 `process_request` 函数，处理了原生缓存与传统上下文补全的互斥关系，更新了缓存查找调用，集成了缓存创建逻辑到 `_attempt_api_call`。
    * **计划:** 完成。
5. **[已实现]** **Key选择逻辑修改 (`app/core/key_manager_class.py`):**
    * **当前状态:** 已修改 `select_best_key` 方法，实现了缓存关联 Key 和用户关联 Key 的优先选择逻辑。
    * **计划:** 完成。
6. **[已实现]** **实现缓存管理模块：**
    * **当前状态:** 已在 `app/core/cache_manager.py` 中实现了缓存创建、获取、查找、删除、过期清理和无效清理的逻辑。
    * **计划:** 完成。
7. **[已实现]** **重构 `GeminiClient` 类 (`app/core/gemini.py`):**
    * **当前状态:** `GeminiClient` 已使用 `google.genai` SDK 并支持 `cached_content_id` 参数。
    * **计划:** 完成。
8. **[已实现]** **更新报告和追踪：**
    * **当前状态:** 已修改 `app/core/reporting.py` 和 `app/core/tracking.py` 以记录和报告缓存命中、节省的 token 等信息。
    * **计划:** 完成。

9. **[已实现]** **增加缓存管理接口和前端支持：**
    * **当前状态:** 已实现。已增加相关的 API 端点和前端界面。
    * **计划:** 完成。

10. **[已实现]** **数据库迁移方案**:
    * **当前状态:** 已创建数据库迁移脚本 `migrations/add_user_id_to_cached_contents.sql`。
    * **计划:** 完成。
11. **[已实现]** **后台清理任务**:
    * **当前状态:** 已修改 `app/core/cache_cleanup.py` 中的 `cleanup_expired_cache` 函数，使其使用 `CacheManager` 实例的方法进行清理。
    * **计划:** 完成。

## 缓存适用内容和管理策略

* **适用内容：** 固定的系统指令和用户上传的大型文档/代码片段。
* **触发机制：**
  * 系统指令：当系统指令的token数超过阈值时自动缓存。
  * 用户上传内容：提供用户选择是否缓存的选项。
* **管理策略：**
  * 使用数据库存储缓存元数据和关联的Key。
  * 利用Gemini API的TTL管理缓存失效。
  * 实现基于内容哈希的缓存查找和更新。
  * 实现基于用户和Key的“粘性会话”Key选择策略。
  * 可选择提供手动管理缓存的接口。

## 流程示意图

```mermaid
graph TD
    A[用户请求] --> B{用户开启原生缓存?};
    B -- 否 --> C[按原有机制处理请求];
    B -- 是 --> D[强制关闭自动补全上下文];
    D --> E{内容是否可缓存?};
    E -- 是 --> F{内容是否已缓存且Key匹配?};
    F -- 是 --> G[构建API请求<br>引用缓存ID];
    F -- 否 --> H[选择Key<br>优先关联Key];
    H --> I{Key选择成功?};
    I -- 是 --> J[构建API请求<br>包含完整内容];
    I -- 否 --> K[Key选择失败<br>返回错误];
    J --> L[调用Gemini API];
    G --> L;
    L --> M[接收API响应];
    M --> N{缓存创建成功?};
    N -- 是 --> O[存储缓存元数据];
    N -- 否 --> P[记录缓存创建失败];
    M --> Q[处理响应<br>解析UsageMetadata];
    Q --> R[更新用户与Key关联];
    Q --> S[返回结果给用户];
    C --> S;
    K --> S;
